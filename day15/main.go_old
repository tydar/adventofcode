package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	f, err := os.Open(os.Args[1])
	if err != nil {
		panic(err)
	}

	scanner := bufio.NewScanner(f)
	costs := make([][]int, 0)
	for scanner.Scan() {
		line := scanner.Text()
		tok := strings.Split(line, "")
		row := make([]int, len(tok))
		for i := range tok {
			n, err := strconv.Atoi(tok[i])
			if err != nil {
				panic(err)
			}
			row[i] = n
		}
		costs = append(costs, row)
	}

	fmt.Println(dijkstra(costs))
}

func dijkstra(costs [][]int) int {
	// returns the lowest cost path from 0,0 to h-1,w-1 (i, j order outer/inner array)
	h := len(costs)
	w := len(costs[0])

	visited := make([][]bool, h)
	distance := make([][]int, h)
	for i := range visited {
		rowV := make([]bool, w)
		rowD := make([]int, w)
		for j := range visited {
			rowV[j] = false
			rowD[j] = -1
		}
		visited[i] = rowV
		distance[i] = rowD
	}

	cI, cJ, v := h-1, w-1, 0
	distance[cI][cJ] = 0
	for !visited[0][0] && v != -1 {
		visit(cI, cJ, distance, costs, visited)
		cI, cJ, v = minVal(distance, visited)
	}

	return distance[0][0] + costs[h-1][w-1] - costs[0][0]
}

func visit(i, j int, distance, costs [][]int, visited [][]bool) {
	// visit sets the distance values for the neighbors of a node i, j
	node := distance[i][j]
	h := len(distance)
	w := len(distance[i])
	nI, nJ := neighbors(i, j, h, w)
	for _, ni := range nI {
		if !visited[ni][j] {
			d := node + costs[ni][j]
			if distance[ni][j] == -1 || distance[ni][j] > d {
				distance[ni][j] = d
			}
		}
	}

	for _, nj := range nJ {
		if !visited[i][nj] {
			d := node + costs[i][nj]
			if distance[i][nj] == -1 || distance[i][nj] > d {
				distance[i][nj] = d
			}
		}
	}

	visited[i][j] = true
}

func neighbors(i, j, h, w int) ([]int, []int) {
	nI, nJ := make([]int, 0), make([]int, 0)
	if i > 0 && i < (h-1) {
		nI = []int{i - 1, i + 1}
	} else if i == 0 {
		nI = []int{i + 1}
	} else {
		nI = []int{i - 1}
	}

	if j > 0 && j < (w-1) {
		nJ = []int{j - 1, j + 1}
	} else if j == 0 {
		nJ = []int{j + 1}
	} else {
		nJ = []int{j - 1}
	}
	return nI, nJ
}

func minVal(a [][]int, visited [][]bool) (int, int, int) {
	min := -1
	minI, minJ := 0, 0
	for i := range a {
		for j := range a[i] {
			if (a[i][j] < min || min == -1) && !visited[i][j] {
				min = a[i][j]
				minI, minJ = i, j
			}
		}
	}
	return minI, minJ, min
}

func prettyPrint(a [][]int) {
	for i := range a {
		for j := range a[i] {
			fmt.Printf("%d ", a[i][j])
		}
		fmt.Println("")
	}
}
